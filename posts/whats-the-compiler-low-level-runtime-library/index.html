<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Understanding compiler runtime libraries: when hardware needs software&#39;s help | José de la Puente | Python and Platform engineering</title>
<meta name="keywords" content="c, compilation, linking, symbols, assembly">
<meta name="description" content="Learn how the compiler inserts functions to execute operations that the machine can&#39;t perform with native instructions.">
<meta name="author" content="">
<link rel="canonical" href="https://josedelapuente.com/posts/whats-the-compiler-low-level-runtime-library/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.48b34cb4ec01d5a55ea252a3cb31382efbd8acfd3b5e2a937505c98c5db1bf22.css" integrity="sha256-SLNMtOwB1aVeolKjyzE4LvvYrP07XiqTdQXJjF2xvyI=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://josedelapuente.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://josedelapuente.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://josedelapuente.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://josedelapuente.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://josedelapuente.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://josedelapuente.com/posts/whats-the-compiler-low-level-runtime-library/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:url" content="https://josedelapuente.com/posts/whats-the-compiler-low-level-runtime-library/">
  <meta property="og:site_name" content="José de la Puente | Python and Platform engineering">
  <meta property="og:title" content="Understanding compiler runtime libraries: when hardware needs software&#39;s help">
  <meta property="og:description" content="Learn how the compiler inserts functions to execute operations that the machine can&#39;t perform with native instructions.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-12-14T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-12-14T00:00:00+00:00">
    <meta property="article:tag" content="C">
    <meta property="article:tag" content="Compilation">
    <meta property="article:tag" content="Linking">
    <meta property="article:tag" content="Symbols">
    <meta property="article:tag" content="Assembly">
      <meta property="og:image" content="https://josedelapuente.com/images/The_Fighting_Temeraire,_JMW_Turner,_National_Gallery.jpg">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://josedelapuente.com/images/The_Fighting_Temeraire,_JMW_Turner,_National_Gallery.jpg">
<meta name="twitter:title" content="Understanding compiler runtime libraries: when hardware needs software&#39;s help">
<meta name="twitter:description" content="Learn how the compiler inserts functions to execute operations that the machine can&#39;t perform with native instructions.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://josedelapuente.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Understanding compiler runtime libraries: when hardware needs software's help",
      "item": "https://josedelapuente.com/posts/whats-the-compiler-low-level-runtime-library/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Understanding compiler runtime libraries: when hardware needs software's help",
  "name": "Understanding compiler runtime libraries: when hardware needs software\u0027s help",
  "description": "Learn how the compiler inserts functions to execute operations that the machine can't perform with native instructions.",
  "keywords": [
    "c", "compilation", "linking", "symbols", "assembly"
  ],
  "articleBody": " This is the third and final article in an introductory series about compilation, linking, and runtime libraries.\nThe first article explored how programs are compiled and linked, and how you can use that to solve symbol errors. It’s the best starting point if you have little context.\nThe second article showed a real-world case study where a missing compiler runtime symbol caused a 6x performance regression in a key journey heavily reliant on Python’s decimal module.\nWhat motivates this final article is the root cause of the missing symbol in the case study: the dynamic linker couldn’t find the compiler’s low-level runtime library. Since that confused me, I’m hoping to explain these libraries to share the context I wish I had when I was debugging the symbol error in _decimal.\nWhat Are Compiler Runtime Libraries? Compiler runtime libraries provide low-level support functions that are automatically called when the compiler determines an operation is too complicated to emit inline code for. Most of its functions are for arithmetic operations that the processor can’t call directly via a native instruction.\nCompiler runtime libraries also have functions for exception handling and miscellaneous operations, but they won’t be the focus of this article.\nThe 2 most common compiler runtime libraries are\nlibgcc for GCC-compiled programs compiler-rt for LLVM compilers like Clang These arithmetic operations are in the compiler rather than language runtimes so that they can be re-used across languages. If they were in each language they’d have to be re-implemented on a per-language basis.\nHow They Work: A Deep Dive on __udivti3 Let’s look at how these libraries help with the most common scenarios: extended precision arithmetic. These are added to your binary files when your code uses types larger than the CPU’s native word size, the compiler runtime kicks in.\nFor example, in my machine the native word size is 64 bits:\n$ getconf LONG_BIT 64 Word sizes are important because they’re the size of a register. A native machine instruction can’t be larger than a register because the computer needs to be able to load the data into a register to execute an instruction.\nSo if I write a program that uses up to 64 bit types like:\nint main() { unsigned int a = 12; unsigned int b = 3; unsigned int result = a / b; } The compiler will translate it to native machine instructions. We can verify this given the minimal symbol table:\n$ nm a.out 0000000100000000 T __mh_execute_header 0000000100000f80 T _main But if I write a program that uses 128 bit types:\nint main() { __uint128_t a = 12; __uint128_t b = 3; __uint128_t result = a / b; } The symbol table will also include __udivti3:\nThe starting __ means that the symbol comes from the compiler or system and isn’t meant to be drectly called in user code. In contrast, user code functions start with a single leading underscore like _main.\n__udivti3 stands for unsigned division tetra integer 3 (the function’s version number). This just means it’s the 3rd version of a function for unsigned division for 128 bit integers.\n$ nm a.out U ___udivti3 0000000100000000 T __mh_execute_header 0000000100000f50 T _main As per before, in this case the symbol __udivti3 is added precisely because these low level runtime libraries provide functions that are too complex to just inline. If they had been inlined we wouldn’t have seen it in the symbol table — only in the disassembly of the binary file.\nIf you’re curious, you can find an almost 200 line C file that implements __udivti3 in LLVM here.\nThus, if the compiler inlined the machine instructions for __udivti3 it would be much harder to make sense of the disassembly of the program.\nUnder the hood, the compiler also inlines multiple instructions to prepare the __udivti3 operation because, as a 128 bit operation in a machine with 64 bit registers, it needs multiple registers to load the data.\nHere’s the full disassembly:\n0000000100000f50 \u003c_main\u003e: 100000f50: 55 pushq %rbp 100000f51: 48 89 e5 movq %rsp, %rbp 100000f54: 48 83 ec 30 subq $48, %rsp 100000f58: 48 c7 45 f8 00 00 00 00 movq $0, -8(%rbp) 100000f60: 48 c7 45 f0 0c 00 00 00 movq $12, -16(%rbp) 100000f68: 48 c7 45 e8 00 00 00 00 movq $0, -24(%rbp) 100000f70: 48 c7 45 e0 03 00 00 00 movq $3, -32(%rbp) 100000f78: 48 8b 7d f0 movq -16(%rbp), %rdi 100000f7c: 48 8b 75 f8 movq -8(%rbp), %rsi 100000f80: 48 8b 55 e0 movq -32(%rbp), %rdx 100000f84: 48 8b 4d e8 movq -24(%rbp), %rcx 100000f88: e8 10 00 00 00 callq 0x100000f9d \u003c___udivti3+0x100000f9d\u003e 100000f8d: 48 89 55 d8 movq %rdx, -40(%rbp) 100000f91: 48 89 45 d0 movq %rax, -48(%rbp) 100000f95: 31 c0 xorl %eax, %eax 100000f97: 48 83 c4 30 addq $48, %rsp 100000f9b: 5d popq %rbp 100000f9c: c3 retq Disassembly of section __TEXT,__stubs: 0000000100000f9d \u003c__stubs\u003e: 100000f9d: ff 25 5d 00 00 00 jmpq *93(%rip) ## 0x100001000 \u003c___udivti3+0x100001000\u003e To break this down into pieces, the first important part is setting up the 2 128 bit number by loading 2 registers per each __uint128_t variable:\n100000f58: 48 c7 45 f8 00 00 00 00 movq $0, -8(%rbp) # Upper 64 bits = 0 100000f60: 48 c7 45 f0 0c 00 00 00 movq $12, -16(%rbp) # Lower 64 bits = 12 100000f68: 48 c7 45 e8 00 00 00 00 movq $0, -24(%rbp) # Upper 64 bits = 0 100000f70: 48 c7 45 e0 03 00 00 00 movq $3, -32(%rbp) # Lower 64 bits = 3 Since the machine uses the base pointer register in the current function’s stack frame (rbp) we now need to move these values from memory to the general purpose registers. This is because in x86-64 there’s a calling convention where, when a function is called, arguments are passed in order to certain registers. For example, the first argument is always loaded into rdi and the second to rsi.\nThus, we then need to load the 2 arguments across 4 registers to be able to call __udivti3:\n100000f78: 48 8b 7d f0 movq -16(%rbp), %rdi # First number lower bits 100000f7c: 48 8b 75 f8 movq -8(%rbp), %rsi # First number upper bits 100000f80: 48 8b 55 e0 movq -32(%rbp), %rdx # Second number lower bits 100000f84: 48 8b 4d e8 movq -24(%rbp), %rcx # Second number upper bits At this point we can call __udivti3 and store the result in 128 bits of the stack frame before returning it:\n100000f88: e8 10 00 00 00 callq ___udivti3 # Call division function 100000f8d: 48 89 55 d8 movq %rdx, -40(%rbp) # Store upper 64 bits of result 100000f91: 48 89 45 d0 movq %rax, -48(%rbp) # Store lower 64 bits of result Takeaways: binary structure and performance implications One of the big takeaways I hope you’re gotten from this is better understanding what programs are made of. In this case, I showed how the compiler also has code it sometimes inserts to make programs compatible across platforms. This can be very helpful when you get linking errors!\nThe other takeaway is that we need to be careful of non-native operations for performance-critical systems. Native instructions are more performant, though the compiler does a lot of heavy lifting to optimize a program’s performance for us, and also lead to a smaller binary size.\n",
  "wordCount" : "1221",
  "inLanguage": "en",
  "image": "https://josedelapuente.com/images/The_Fighting_Temeraire,_JMW_Turner,_National_Gallery.jpg","datePublished": "2024-12-14T00:00:00Z",
  "dateModified": "2024-12-14T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://josedelapuente.com/posts/whats-the-compiler-low-level-runtime-library/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "José de la Puente | Python and Platform engineering",
    "logo": {
      "@type": "ImageObject",
      "url": "https://josedelapuente.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    
    document.body.classList.add('dark');
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://josedelapuente.com/" accesskey="h" title="José de la Puente (Alt + H)">José de la Puente</a>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Understanding compiler runtime libraries: when hardware needs software&#39;s help
    </h1>
    <div class="post-description">
      Learn how the compiler inserts functions to execute operations that the machine can&#39;t perform with native instructions.
    </div>
    <div class="post-meta"><span title='2024-12-14 00:00:00 +0000 UTC'>December 14, 2024</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#what-are-compiler-runtime-libraries" aria-label="What Are Compiler Runtime Libraries?">What Are Compiler Runtime Libraries?</a></li>
                <li>
                    <a href="#how-they-work-a-deep-dive-on-__udivti3" aria-label="How They Work: A Deep Dive on __udivti3">How They Work: A Deep Dive on __udivti3</a></li>
                <li>
                    <a href="#takeaways-binary-structure-and-performance-implications" aria-label="Takeaways: binary structure and performance implications">Takeaways: binary structure and performance implications</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><blockquote>
<p>This is the third and final article in an introductory series about compilation, linking, and runtime libraries.</p>
<p>The <a href="/posts/how-to-diagnose-and-mitigate-linking-errors/">first article</a> explored how programs are compiled and linked, and how you can use that to solve symbol errors. It&rsquo;s the best starting point if you have little context.</p>
<p>The <a href="/posts/python-decimal-module-performance-optimization/">second article</a> showed a real-world case study where a missing compiler runtime symbol caused a 6x performance regression in a key journey heavily reliant on Python&rsquo;s <code>decimal</code> module.</p></blockquote>
<p>What motivates this final article is the root cause of the missing symbol in the case study: the dynamic linker couldn&rsquo;t find the compiler&rsquo;s low-level runtime library. Since that confused me, I&rsquo;m hoping to explain these libraries to share the context I wish I had when I was debugging the symbol error in <code>_decimal</code>.</p>
<h2 id="what-are-compiler-runtime-libraries">What Are Compiler Runtime Libraries?<a hidden class="anchor" aria-hidden="true" href="#what-are-compiler-runtime-libraries">#</a></h2>
<p>Compiler runtime libraries provide low-level support functions that are automatically called when the compiler determines an operation is too complicated to emit inline code for. Most of its functions are for arithmetic operations that the processor can&rsquo;t call directly via a native instruction.</p>
<blockquote>
<p>Compiler runtime libraries also have functions for exception handling and miscellaneous operations, but they won&rsquo;t be the focus of this article.</p></blockquote>
<p>The 2 most common compiler runtime libraries are</p>
<ul>
<li><code>libgcc</code> for GCC-compiled programs</li>
<li><code>compiler-rt</code> for LLVM compilers like Clang</li>
</ul>
<blockquote>
<p>These arithmetic operations are in the compiler rather than language runtimes so that they can be re-used across languages. If they were in each language they&rsquo;d have to be re-implemented on a per-language basis.</p></blockquote>
<h2 id="how-they-work-a-deep-dive-on-__udivti3">How They Work: A Deep Dive on <code>__udivti3</code><a hidden class="anchor" aria-hidden="true" href="#how-they-work-a-deep-dive-on-__udivti3">#</a></h2>
<p>Let&rsquo;s look at how these libraries help with the most common scenarios: extended precision arithmetic. These are added to your binary files when your code uses types larger than the CPU&rsquo;s native word size, the compiler runtime kicks in.</p>
<p>For example, in my machine the native word size is 64 bits:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ getconf LONG_BIT
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">64</span>
</span></span></code></pre></div><blockquote>
<p>Word sizes are important because they&rsquo;re the size of a register. A native machine instruction can&rsquo;t be larger than a register because the computer needs to be able to load the data into a register to execute an instruction.</p></blockquote>
<p>So if I write a program that uses up to 64 bit types like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> a <span style="color:#f92672">/</span> b;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The compiler will translate it to native machine instructions. We can verify this given the minimal symbol table:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ nm a.out
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000100000000</span> T __mh_execute_header
</span></span><span style="display:flex;"><span>0000000100000f80 T _main
</span></span></code></pre></div><p>But if I write a program that uses 128 bit types:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  __uint128_t a <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>;
</span></span><span style="display:flex;"><span>  __uint128_t b <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>  __uint128_t result <span style="color:#f92672">=</span> a <span style="color:#f92672">/</span> b;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The symbol table will also include <code>__udivti3</code>:</p>
<blockquote>
<p>The starting <code>__</code> means that the symbol comes from the compiler or system and isn&rsquo;t meant to be drectly called in user code. In contrast, user code functions start with a single leading underscore like <code>_main</code>.</p>
<p><code>__udivti3</code> stands for <strong>u</strong>nsigned <strong>div</strong>ision <strong>t</strong>etra integer 3 (the function&rsquo;s version number). This just means it&rsquo;s the 3rd version of a function for unsigned division for 128 bit integers.</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ nm a.out
</span></span><span style="display:flex;"><span>                 U ___udivti3
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000100000000</span> T __mh_execute_header
</span></span><span style="display:flex;"><span>0000000100000f50 T _main
</span></span></code></pre></div><p>As per before, in this case the symbol <code>__udivti3</code> is added precisely because these low level runtime libraries provide functions that are too complex to just inline. If they had been inlined we wouldn&rsquo;t have seen it in the symbol table — only in the disassembly of the binary file.</p>
<blockquote>
<p>If you&rsquo;re curious, you can find an almost 200 line C file that implements <code>__udivti3</code> in LLVM <a href="https://github.com/llvm-mirror/compiler-rt/blob/master/lib/builtins/udivmodti4.c">here</a>.</p>
<p>Thus, if the compiler inlined the machine instructions for <code>__udivti3</code> it would be much harder to make sense of the disassembly of the program.</p></blockquote>
<p>Under the hood, the compiler also inlines multiple instructions to prepare the <code>__udivti3</code> operation because, as a 128 bit operation in a machine with 64 bit registers, it needs multiple registers to load the data.</p>
<p>Here&rsquo;s the full disassembly:</p>
<pre tabindex="0"><code class="language-objdump" data-lang="objdump">0000000100000f50 &lt;_main&gt;:
100000f50: 55                           pushq   %rbp
100000f51: 48 89 e5                     movq    %rsp, %rbp
100000f54: 48 83 ec 30                  subq    $48, %rsp
100000f58: 48 c7 45 f8 00 00 00 00      movq    $0, -8(%rbp)
100000f60: 48 c7 45 f0 0c 00 00 00      movq    $12, -16(%rbp)
100000f68: 48 c7 45 e8 00 00 00 00      movq    $0, -24(%rbp)
100000f70: 48 c7 45 e0 03 00 00 00      movq    $3, -32(%rbp)
100000f78: 48 8b 7d f0                  movq    -16(%rbp), %rdi
100000f7c: 48 8b 75 f8                  movq    -8(%rbp), %rsi
100000f80: 48 8b 55 e0                  movq    -32(%rbp), %rdx
100000f84: 48 8b 4d e8                  movq    -24(%rbp), %rcx
100000f88: e8 10 00 00 00               callq   0x100000f9d &lt;___udivti3+0x100000f9d&gt;
100000f8d: 48 89 55 d8                  movq    %rdx, -40(%rbp)
100000f91: 48 89 45 d0                  movq    %rax, -48(%rbp)
100000f95: 31 c0                        xorl    %eax, %eax
100000f97: 48 83 c4 30                  addq    $48, %rsp
100000f9b: 5d                           popq    %rbp
100000f9c: c3                           retq

Disassembly of section __TEXT,__stubs:

0000000100000f9d &lt;__stubs&gt;:
100000f9d: ff 25 5d 00 00 00            jmpq    *93(%rip)               ## 0x100001000 &lt;___udivti3+0x100001000&gt;
</code></pre><p>To break this down into pieces, the first important part is setting up the 2 128 bit number by loading 2 registers per each <code>__uint128_t</code> variable:</p>
<pre tabindex="0"><code class="language-objdump" data-lang="objdump">100000f58: 48 c7 45 f8 00 00 00 00      movq    $0, -8(%rbp)   # Upper 64 bits = 0
100000f60: 48 c7 45 f0 0c 00 00 00      movq    $12, -16(%rbp) # Lower 64 bits = 12
100000f68: 48 c7 45 e8 00 00 00 00      movq    $0, -24(%rbp)  # Upper 64 bits = 0
100000f70: 48 c7 45 e0 03 00 00 00      movq    $3, -32(%rbp)  # Lower 64 bits = 3
</code></pre><p>Since the machine uses the base pointer register in the current function&rsquo;s stack frame (<code>rbp</code>) we now need to move these values from memory to the general purpose registers. This is because in <code>x86-64</code> there&rsquo;s a calling convention where, when a function is called, arguments are passed in order to certain registers. For example, the first argument is always loaded into <code>rdi</code> and the second to <code>rsi</code>.</p>
<p>Thus, we then need to load the 2 arguments across 4 registers to be able to call <code>__udivti3</code>:</p>
<pre tabindex="0"><code class="language-objdump" data-lang="objdump">100000f78: 48 8b 7d f0                  movq    -16(%rbp), %rdi  # First number lower bits
100000f7c: 48 8b 75 f8                  movq    -8(%rbp), %rsi   # First number upper bits
100000f80: 48 8b 55 e0                  movq    -32(%rbp), %rdx  # Second number lower bits
100000f84: 48 8b 4d e8                  movq    -24(%rbp), %rcx  # Second number upper bits
</code></pre><p>At this point we can call <code>__udivti3</code> and store the result in 128 bits of the stack frame before returning it:</p>
<pre tabindex="0"><code class="language-objdump" data-lang="objdump">100000f88: e8 10 00 00 00               callq   ___udivti3       # Call division function
100000f8d: 48 89 55 d8                  movq    %rdx, -40(%rbp)  # Store upper 64 bits of result
100000f91: 48 89 45 d0                  movq    %rax, -48(%rbp)  # Store lower 64 bits of result
</code></pre><h2 id="takeaways-binary-structure-and-performance-implications">Takeaways: binary structure and performance implications<a hidden class="anchor" aria-hidden="true" href="#takeaways-binary-structure-and-performance-implications">#</a></h2>
<p>One of the big takeaways I hope you&rsquo;re gotten from this is better understanding what programs are made of. In this case, I showed how the compiler also has code it sometimes inserts to make programs compatible across platforms. This can be very helpful when you get linking errors!</p>
<p>The other takeaway is that we need to be careful of non-native operations for performance-critical systems. Native instructions are more performant, though the compiler does a lot of heavy lifting to optimize a program&rsquo;s performance for us, and also lead to a smaller binary size.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://josedelapuente.com/tags/c/">C</a></li>
      <li><a href="https://josedelapuente.com/tags/compilation/">Compilation</a></li>
      <li><a href="https://josedelapuente.com/tags/linking/">Linking</a></li>
      <li><a href="https://josedelapuente.com/tags/symbols/">Symbols</a></li>
      <li><a href="https://josedelapuente.com/tags/assembly/">Assembly</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
